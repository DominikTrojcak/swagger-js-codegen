/* tslint:disable */
import 'isomorphic-fetch';

{{#imports}}
/// <reference path="{{&.}}" />
{{/imports}}

type QueryParameters = { [key: string]: string | number | string[] | number[] | undefined };

{{#definitions}}
export type {{&name}} = {{#tsType}}{{> type}}{{/tsType}};
{{/definitions}}

class ApiError {
  public message: string;
  public details: Error;

  constructor(message: string) {
    this.message = message;
  }
}

const queryParametersToSnakeCase = (parameters: QueryParameters) => {
    const snakeCaseParams: any = {};

    Object.keys(parameters).map(key => {
        const value = parameters[key];

        snakeCaseParams[toSnakeCase(key)] = value;
    });

    return snakeCaseParams;
}

const toSnakeCase = (msg: string) => {
    const upperChars = msg.match(/([A-Z])/g);
    if (! upperChars) {
        return msg;
    }

    let str = msg.toString();
    for (var i = 0, n = upperChars.length; i < n; i++) {
        str = str.replace(new RegExp(upperChars[i]), '_' + upperChars[i].toLowerCase());
    }

    if (str.slice(0, 1) === '_') {
        str = str.slice(1);
    }
    return str;
}

/**
 * {{&description}}
 * @class {{&className}}
 * @param {(string)} [domainOrOptions] - The project domain.
 */
class {{&className}} {

    protected baseUrl: string = "{{&domain}}";
    {{#isSecure}}
        {{#isSecureToken}}
    protected token: string;
        {{/isSecureToken}}
        {{#isSecureApiKey}}
    protected apiKey: string;
        {{/isSecureApiKey}}
    {{/isSecure}}

    serializeQueryParams(parameters: QueryParameters) {
        const str: string[] = [];
        for (let p in parameters) {
            if (parameters.hasOwnProperty(p)) {
                if(parameters[p] !== undefined) {    
                    const parameter = parameters[p] || "";
                    str.push(`${encodeURIComponent(p)}=${encodeURIComponent(parameter.toString())}`);
                }
            }
        }
        return str.join('&');
    }

    public setBaseUrl(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    {{#isSecure}}
        {{#isSecureToken}}
    public setToken(token: string) {
        this.token = token;
    }
        {{/isSecureToken}}

    {{#isSecureApiKey}}
        public setApiKey(apiKey: string) {
        this.apiKey = apiKey;
        }
    {{/isSecureApiKey}}

    protected appendAuthHeaders(headerParams: Headers) {
      const headers = new Headers(headerParams);
    {{#isSecureToken}}
      if (this.token) {
        headers.append('Authorization', `Bearer ${this.token}`);
      }
    {{/isSecureToken}}

    {{#isSecureApiKey}}
        if (this.apiKey) {
            headers.append('{{apiKeyHeaderName}}', this.apiKey);
        }
    {{/isSecureApiKey}}

      return headers;
    }
    {{/isSecure}}

    private async request(method: string, url: string, body: any, headers: any, queryParameters: QueryParameters) {
        const queryParams = queryParameters && Object.keys(queryParameters).length ? this.serializeQueryParams(queryParameters) : null ;
        const urlWithParams = url + (queryParams ? '?' + queryParams : '');

        if (body && !Object.keys(body).length) {
            body = undefined;
        } else {
            body = JSON.stringify(body);
        }

        const response = await fetch(urlWithParams, { method, headers, body });
        if(response.ok) {
            return response.json();
        } else {
            const err = new ApiError(response.statusText);
            err.details = await response.json();
            throw err;
        }
    }

{{#methods}}
    {{> method}}

{{/methods}}
}

export default new {{&className}}();
